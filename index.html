<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ukiyo-e Grid Game</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        button {
            padding: 8px 16px;
            border: none;
            background-color: rgba(76, 175, 80, 0.7);
            color: white;
            font-size: 16px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover {
            background-color: rgba(69, 160, 73, 0.9);
        }
        .instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            text-align: center;
            max-width: 500px;
            font-family: 'Arial', sans-serif;
            letter-spacing: 1px;
        }
        /* Vignette overlay */
        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 150px rgba(0, 0, 0, 0.7);
            pointer-events: none;
            z-index: 10;
        }
        /* Paper texture overlay */
        .paper-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://www.transparenttextures.com/patterns/rice-paper-3.png');
            opacity: 0.15;
            pointer-events: none;
            z-index: 5;
        }
        /* Score counter */
        .score-container {
            position: absolute;
            top: 20px;
            right: 30px;
            background-color: rgba(0, 0, 0, 0.5);
            color: #ffefd5;
            padding: 10px 20px;
            border-radius: 4px;
            text-align: center;
            font-family: 'Arial', sans-serif;
            letter-spacing: 1px;
            border: 2px solid #bc002d;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(255, 106, 0, 0.4);
        }
        .score-title {
            font-size: 14px;
            margin: 0 0 5px 0;
            text-transform: uppercase;
            color: #e4b1ab;
        }
        .score-value {
            font-size: 28px;
            margin: 0;
            color: #ffefd5;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div class="controls">
        <button id="turn-left">Turn Left</button>
        <button id="pause">Pause</button>
        <button id="turn-right">Turn Right</button>
    </div>
    <div class="instructions">
        <p>Use arrow keys or buttons to control: Left/Right arrows to turn, Space to pause/resume.</p>
        <p>The character will automatically move forward in the current direction.</p>
    </div>
    <div class="score-container">
        <p class="score-title">Score</p>
        <p class="score-value" id="score-display">0</p>
    </div>
    <div class="vignette"></div>
    <div class="paper-texture"></div>

    <script>
        // Game parameters
        const gridSize = 60;
        const cellSize = 12;
        const wallHeight = 0.5;
        const moveInterval = 800; // ms between moves
        const brickHeight = 0.7; // Increased from 0.4 to 0.7
        const initialBrickHeight = 0.5; // Increased from 0.3 to 0.5
        
        // Game state
        let playerPosition = { x: Math.floor(gridSize / 2), y: 0, z: Math.floor(gridSize / 2) };
        let direction = 0; // 0: north, 1: east, 2: south, 3: west
        let isMoving = true;
        let visitedCells = {};
        let score = 0; // Initialize score counter
        let clock = new THREE.Clock();
        let deltaTime = 0;
        let moveCooldown = 0;
        let isTransitioning = false;
        let targetPosition = { x: 0, y: 0, z: 0 };
        let startPosition = { x: 0, y: 0, z: 0 };
        let transitionProgress = 0;
        let transitionDuration = 0.4; // seconds
        let isRotating = false;
        let currentRotation = Math.PI; // Initialize to match direction 0 (north)
        let targetRotation = Math.PI; // Initialize to match direction 0 (north)
        let rotationProgress = 0;
        let rotationDuration = 0.3; // seconds
        
        // Directions as vectors [dx, dz]
        const directions = [
            [0, -1], // north (z decreases as we move forward)
            [1, 0],  // east
            [0, 1],  // south
            [-1, 0]  // west
        ];
        
        // Set up the scene
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xd7c0a1, 0.003); // Decreased fog density for larger world
        
        // Set up the camera
        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 15;
        
        // Set up the renderer with post-processing
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xe8dccf); // Soft cream paper color
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        
        // Set up post-processing
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        // Add bloom for soft glow effect
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.4,  // strength (increased slightly)
            0.5,  // radius (increased slightly)
            0.8   // threshold
        );
        composer.addPass(bloomPass);
        
        // Add a sun (directional light)
        const sunLight = new THREE.DirectionalLight(0xfff1e0, 1.2);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        
        // Improve shadow quality
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        
        scene.add(sunLight);
        
        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xe8d0bf, 0.4); // Warm ambient light
        scene.add(ambientLight);
        
        // Create a sun sphere
        const sunGeometry = new THREE.SphereGeometry(15, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff6a00, // More orange sun for ukiyo-e styling
            emissive: 0xff4500,
            emissiveIntensity: 0.5
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(120, 100, 120);
        scene.add(sun);
        
        // Create a moon opposite to the sun
        const moonGeometry = new THREE.SphereGeometry(10, 32, 32);
        
        // Create a canvas for the moon texture
        const moonCanvas = document.createElement('canvas');
        moonCanvas.width = 512;
        moonCanvas.height = 512;
        const moonContext = moonCanvas.getContext('2d');
        
        // Draw moon with soft glow and craters
        moonContext.fillStyle = '#f1f1ee';
        moonContext.beginPath();
        moonContext.arc(moonCanvas.width/2, moonCanvas.height/2, moonCanvas.width/2 - 10, 0, Math.PI * 2);
        moonContext.fill();
        
        // Add some craters
        for (let i = 0; i < 20; i++) {
            const craterSize = 5 + Math.random() * 25;
            const craterX = Math.random() * moonCanvas.width * 0.7 + moonCanvas.width * 0.15;
            const craterY = Math.random() * moonCanvas.height * 0.7 + moonCanvas.height * 0.15;
            
            moonContext.fillStyle = `rgba(200, 200, 200, ${0.2 + Math.random() * 0.3})`;
            moonContext.beginPath();
            moonContext.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
            moonContext.fill();
        }
        
        // Create moon texture and material
        const moonTexture = new THREE.CanvasTexture(moonCanvas);
        const moonMaterial = new THREE.MeshBasicMaterial({
            map: moonTexture,
            emissive: 0xf1f1ee,
            emissiveIntensity: 0.2
        });
        
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(-120, 80, -120);
        scene.add(moon);
        
        // Create sky dome
        const skyGeometry = new THREE.SphereGeometry(400, 32, 32);
        
        // Create a canvas for the sky gradient
        const skyCanvas = document.createElement('canvas');
        skyCanvas.width = 1024;
        skyCanvas.height = 1024;
        const skyContext = skyCanvas.getContext('2d');
        
        // Create a gradient sky typical of ukiyo-e
        const skyGradient = skyContext.createLinearGradient(0, 0, 0, skyCanvas.height);
        skyGradient.addColorStop(0, '#ffecd2'); // Light cream at top
        skyGradient.addColorStop(0.5, '#ffcb95'); // Orangish in middle
        skyGradient.addColorStop(1, '#e4b1ab');   // Pink-ish at bottom
        
        skyContext.fillStyle = skyGradient;
        skyContext.fillRect(0, 0, skyCanvas.width, skyCanvas.height);
        
        // Create a texture from the canvas
        const skyTexture = new THREE.CanvasTexture(skyCanvas);
        
        const skyMaterial = new THREE.MeshBasicMaterial({ 
            map: skyTexture,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);
        
        // Create ground plane with a more textured feel
        const groundSize = gridSize * cellSize * 4;
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
        
        // Create textured ground
        const groundCanvas = document.createElement('canvas');
        groundCanvas.width = 2048;  // Increased resolution
        groundCanvas.height = 2048; // Increased resolution
        const groundContext = groundCanvas.getContext('2d');
        
        // Fill with base color
        groundContext.fillStyle = '#d3c7a6'; // Muted tan color
        groundContext.fillRect(0, 0, groundCanvas.width, groundCanvas.height);
        
        // Add more complex terrain-like texture
        // First, create a gradient background
        const terrainGradient = groundContext.createRadialGradient(
            groundCanvas.width/2, groundCanvas.height/2, 0,
            groundCanvas.width/2, groundCanvas.height/2, groundCanvas.width/2
        );
        terrainGradient.addColorStop(0, 'rgba(216, 206, 172, 0.7)');
        terrainGradient.addColorStop(1, 'rgba(195, 185, 155, 0.5)');
        
        groundContext.fillStyle = terrainGradient;
        groundContext.fillRect(0, 0, groundCanvas.width, groundCanvas.height);
        
        // Add terrain-like patterns
        for (let i = 0; i < 30; i++) {
            // Draw wavy lines for terrain effect
            groundContext.strokeStyle = `rgba(180, 170, 140, ${0.1 + Math.random() * 0.1})`;
            groundContext.lineWidth = 2 + Math.random() * 5;
            
            groundContext.beginPath();
            let startX = 0;
            let startY = Math.random() * groundCanvas.height;
            groundContext.moveTo(startX, startY);
            
            // Create wiggly paths
            for (let x = 0; x < groundCanvas.width; x += 80) {
                const offsetY = Math.sin(x * 0.01 + i) * 100 + Math.random() * 50;
                groundContext.lineTo(x, startY + offsetY);
            }
            groundContext.stroke();
        }
        
        // Add noise texture
        for (let i = 0; i < 100000; i++) {
            const x = Math.random() * groundCanvas.width;
            const y = Math.random() * groundCanvas.height;
            const radius = Math.random() * 2;
            groundContext.beginPath();
            groundContext.arc(x, y, radius, 0, Math.PI * 2);
            groundContext.fillStyle = `rgba(185, 175, 150, ${Math.random() * 0.2})`;
            groundContext.fill();
        }
        
        // Create ground texture
        const groundTexture = new THREE.CanvasTexture(groundCanvas);
        groundTexture.wrapS = THREE.RepeatWrapping;
        groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(4, 4);
        
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            map: groundTexture,
            roughness: 0.9,
            metalness: 0.1,
            color: 0xc7bb99
        });
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        ground.position.y = -0.01; // Slightly below grid
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Create grid with walls
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x808080,
            roughness: 0.7
        });
        const gridGroup = new THREE.Group();
        
        // Create grid cells
        for (let x = 0; x < gridSize; x++) {
            for (let z = 0; z < gridSize; z++) {
                // Create floor tile for each cell - now with some height
                const floorGeometry = new THREE.BoxGeometry(cellSize, initialBrickHeight, cellSize);
                
                // Create a canvas for the default tile texture - without grid lines
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = 256;
                tileCanvas.height = 256;
                const tileCtx = tileCanvas.getContext('2d');
                
                // Fill with base color
                tileCtx.fillStyle = '#e1d9c8'; // Soft cream color
                tileCtx.fillRect(0, 0, tileCanvas.width, tileCanvas.height);
                
                // Add subtle texture without grid pattern
                for (let i = 0; i < 300; i++) {
                    const dotX = Math.random() * tileCanvas.width;
                    const dotY = Math.random() * tileCanvas.height;
                    tileCtx.fillStyle = `rgba(190, 180, 160, ${Math.random() * 0.3})`;
                    tileCtx.beginPath();
                    tileCtx.arc(dotX, dotY, 1 + Math.random() * 3, 0, Math.PI * 2);
                    tileCtx.fill();
                }
                
                // Add a subtle edge/border
                tileCtx.strokeStyle = '#d3c7a6';
                tileCtx.lineWidth = 6;
                tileCtx.strokeRect(3, 3, tileCanvas.width-6, tileCanvas.height-6);
                
                const tileTexture = new THREE.CanvasTexture(tileCanvas);
                
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    map: tileTexture,
                    color: 0xe1d9c8, // Soft cream color
                    transparent: true,
                    opacity: 0.9,
                    roughness: 0.8
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.position.set(
                    (x - gridSize/2) * cellSize + cellSize/2,
                    initialBrickHeight / 2, // Position at half the height
                    (z - gridSize/2) * cellSize + cellSize/2
                );
                floor.userData = { 
                    type: 'floor', 
                    gridX: x, 
                    gridZ: z,
                    stackHeight: 1, // Start with 1 layer
                    brickHeight: initialBrickHeight
                };
                floor.receiveShadow = true;
                floor.castShadow = true;
                gridGroup.add(floor);
            }
        }
        
        scene.add(gridGroup);
        
        // Create player (red ball with traditional design)
        const playerGeometry = new THREE.SphereGeometry(0.8, 32, 32);
        
        // Create a canvas for the player texture
        const playerCanvas = document.createElement('canvas');
        playerCanvas.width = 256;
        playerCanvas.height = 256;
        const playerContext = playerCanvas.getContext('2d');
        
        // Draw a traditional Japanese-style ball pattern
        playerContext.fillStyle = '#bc002d'; // Traditional red
        playerContext.fillRect(0, 0, playerCanvas.width, playerCanvas.height);
        
        // Add wave design
        playerContext.strokeStyle = '#ffffff';
        playerContext.lineWidth = 5;
        const waveCount = 6;
        const waveHeight = 10;
        
        for (let i = 0; i < waveCount; i++) {
            playerContext.beginPath();
            for (let x = 0; x < playerCanvas.width; x += 5) {
                const y = playerCanvas.height / 2 + Math.sin(x * 0.05 + i) * waveHeight + i * 20;
                if (x === 0) {
                    playerContext.moveTo(x, y);
                } else {
                    playerContext.lineTo(x, y);
                }
            }
            playerContext.stroke();
        }
        
        // Create texture from canvas
        const playerTexture = new THREE.CanvasTexture(playerCanvas);
        
        const playerMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, // White base to show texture properly
            map: playerTexture,
            emissive: 0xbc002d,
            emissiveIntensity: 0.2,
            roughness: 0.4,
            metalness: 0.2
        });
        
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(
            (playerPosition.x - gridSize/2) * cellSize + cellSize/2,
            playerPosition.y + 0.8 + initialBrickHeight, // Position on top of initial brick
            (playerPosition.z - gridSize/2) * cellSize + cellSize/2
        );
        
        // Add shadow to player
        player.castShadow = true;
        
        scene.add(player);
        
        // Initial camera positioning
        updateCameraPosition();
        
        // Mark starting cell as visited
        markCellAsVisited(playerPosition.x, playerPosition.z);
        
        // Game loop with smooth transitions
        function animate() {
            requestAnimationFrame(animate);
            
            deltaTime = clock.getDelta();
            
            // Handle movement transitions (jump animation)
            if (isTransitioning) {
                transitionProgress += deltaTime / transitionDuration;
                
                if (transitionProgress >= 1) {
                    // Transition complete
                    transitionProgress = 1;
                    isTransitioning = false;
                    moveCooldown = moveInterval / 1000 - transitionDuration; // Subtract transition time from cooldown
                }
                
                // Interpolate position with jump arc
                player.position.x = startPosition.x + (targetPosition.x - startPosition.x) * transitionProgress;
                player.position.z = startPosition.z + (targetPosition.z - startPosition.z) * transitionProgress;
                
                // Add jump height - parabola that peaks in the middle of the jump
                const jumpHeight = Math.sin(Math.PI * transitionProgress) * 2;
                player.position.y = startPosition.y + jumpHeight;
                
                // Update camera to follow player
                updateCameraPosition();
            } else {
                // Reset y position when not jumping - now based on the height of current brick
                updatePlayerRestingHeight();
            }
            
            // Handle camera rotation
            if (isRotating) {
                rotationProgress += deltaTime / rotationDuration;
                
                if (rotationProgress >= 1) {
                    // Rotation complete
                    rotationProgress = 1;
                    isRotating = false;
                    currentRotation = targetRotation;
                }
                
                // Smooth camera rotation
                updateCameraRotation();
            }
            
            if (moveCooldown > 0) {
                moveCooldown -= deltaTime;
            } else if (isMoving && !isTransitioning) {
                // Time to move again (only if not already moving)
                movePlayer();
            }
            
            // Rotate sun
            sun.position.x = 120 * Math.cos(clock.elapsedTime * 0.03);
            sun.position.z = 120 * Math.sin(clock.elapsedTime * 0.3);
            
            // Move moon in opposite direction
            moon.position.x = -120 * Math.cos(clock.elapsedTime * 0.03);
            moon.position.z = -120 * Math.sin(clock.elapsedTime * 0.3);
            
            // Update sunlight direction
            sunLight.position.copy(sun.position);
            
            renderer.render(scene, camera);
        }
        
        // Update player's resting height based on current tile height
        function updatePlayerRestingHeight() {
            const currentX = playerPosition.x;
            const currentZ = playerPosition.z;
            const cellKey = `${currentX}-${currentZ}`;
            
            if (visitedCells[cellKey]) {
                // Get number of visits to calculate height
                const visits = visitedCells[cellKey].visits;
                const totalHeight = initialBrickHeight + (visits - 1) * brickHeight;
                player.position.y = 0.8 + totalHeight; // Ball radius + stack height
            } else {
                player.position.y = 0.8 + initialBrickHeight; // Ball radius + initial height
            }
        }
        
        // Move the player with smooth transitions
        function movePlayer() {
            if (!isMoving || isTransitioning) return;
            
            // Get current direction vector
            const [dx, dz] = directions[direction];
            
            // Calculate new position
            const newX = playerPosition.x + dx;
            const newZ = playerPosition.z + dz;
            
            // Check if new position is within bounds
            if (newX >= 0 && newX < gridSize && newZ >= 0 && newZ < gridSize) {
                // Update grid position before start transition
                // This ensures we can calculate the correct target height
                playerPosition.x = newX;
                playerPosition.z = newZ;
                
                // Mark cell as visited (do this before calculating target position)
                markCellAsVisited(playerPosition.x, playerPosition.z);
                
                // Start transition to new position
                isTransitioning = true;
                transitionProgress = 0;
                
                // Store start position
                startPosition = {
                    x: player.position.x,
                    y: player.position.y,
                    z: player.position.z
                };
                
                // Calculate target position with correct height for the destination cell
                const cellKey = `${newX}-${newZ}`;
                let targetHeight = initialBrickHeight;
                
                if (visitedCells[cellKey]) {
                    const visits = visitedCells[cellKey].visits;
                    targetHeight = initialBrickHeight + (visits - 1) * brickHeight;
                }
                
                // Calculate world position from grid position
                targetPosition = {
                    x: (newX - gridSize/2) * cellSize + cellSize/2,
                    y: 0.8 + targetHeight, // Set correct height for landing
                    z: (newZ - gridSize/2) * cellSize + cellSize/2
                };
                
            } else {
                // Hit the boundary, turn around
                direction = (direction + 2) % 4;
                updateCameraRotation();
            }
        }
        
        // Mark a cell as visited and stack a brick
        function markCellAsVisited(x, z) {
            const cellKey = `${x}-${z}`;
            
            // If first visit, initialize with visit count 1
            if (!visitedCells[cellKey]) {
                visitedCells[cellKey] = { 
                    visits: 1, 
                    bricks: [] 
                };
                // Increase score for first visit too
                incrementScore();
            } else {
                // Increment visit count and score for additional visits
                visitedCells[cellKey].visits++;
                // Increase score when adding a new brick
                incrementScore();
            }
            
            // Find the floor at this position
            gridGroup.children.forEach(child => {
                if (child.userData.type === 'floor' && 
                    child.userData.gridX === x && 
                    child.userData.gridZ === z) {
                    
                    const visits = visitedCells[cellKey].visits;
                    
                    // If this is the first visit, just change the material of existing tile
                    if (visits === 1) {
                        // Create a canvas for a textured path
                        const pathCanvas = document.createElement('canvas');
                        pathCanvas.width = 256;
                        pathCanvas.height = 256;
                        const ctx = pathCanvas.getContext('2d');
                        
                        // Fill with red base
                        ctx.fillStyle = '#bc002d'; // Traditional Japanese red
                        ctx.fillRect(0, 0, pathCanvas.width, pathCanvas.height);
                        
                        // Add some texture lines (brushstrokes)
                        ctx.strokeStyle = '#9b001e';
                        ctx.lineWidth = 3;
                        
                        for (let i = 0; i < 10; i++) {
                            ctx.beginPath();
                            ctx.moveTo(Math.random() * pathCanvas.width, 0);
                            ctx.lineTo(Math.random() * pathCanvas.width, pathCanvas.height);
                            ctx.stroke();
                            
                            ctx.beginPath();
                            ctx.moveTo(0, Math.random() * pathCanvas.height);
                            ctx.lineTo(pathCanvas.width, Math.random() * pathCanvas.height);
                            ctx.stroke();
                        }
                        
                        // Add a subtle edge/border
                        ctx.strokeStyle = '#8c001d';
                        ctx.lineWidth = 6;
                        ctx.strokeRect(3, 3, pathCanvas.width-6, pathCanvas.height-6);
                        
                        // Create a texture from the canvas
                        const pathTexture = new THREE.CanvasTexture(pathCanvas);
                        
                        // Change material to textured red path
                        child.material = new THREE.MeshStandardMaterial({
                            color: 0xbc002d, // Traditional red
                            map: pathTexture,
                            roughness: 0.8,
                            transparent: false,
                            opacity: 1
                        });
                    } else {
                        // For subsequent visits, add a brick on top
                        addBrickOnTop(x, z, visits);
                    }
                }
            });
        }
        
        // Add a brick on top of existing stack
        function addBrickOnTop(x, z, stackLevel) {
            const cellKey = `${x}-${z}`;
            const brickStack = visitedCells[cellKey].bricks;
            
            // Calculate position for the new brick
            const worldX = (x - gridSize/2) * cellSize + cellSize/2;
            const worldZ = (z - gridSize/2) * cellSize + cellSize/2;
            
            // Calculate brick height
            // First brick has height initialBrickHeight
            // Additional bricks have height brickHeight
            const baseHeight = initialBrickHeight;
            const currentStackHeight = baseHeight + (stackLevel - 2) * brickHeight;
            const worldY = currentStackHeight + brickHeight / 2;
            
            // Create brick geometry (slightly smaller than the base tile)
            const brickGeometry = new THREE.BoxGeometry(
                cellSize * 0.95, 
                brickHeight, 
                cellSize * 0.95
            );
            
            // Create a canvas for the brick texture
            const brickCanvas = document.createElement('canvas');
            brickCanvas.width = 256;
            brickCanvas.height = 256;
            const ctx = brickCanvas.getContext('2d');
            
            // Fill with red base
            ctx.fillStyle = '#bc002d'; // Traditional Japanese red
            ctx.fillRect(0, 0, brickCanvas.width, brickCanvas.height);
            
            // Vary the pattern slightly for each level
            const patternIntensity = 0.2 + (stackLevel % 3) * 0.1;
            ctx.strokeStyle = `rgba(155, 0, 30, ${patternIntensity})`;
            ctx.lineWidth = 2 + (stackLevel % 3);
            
            // Add some texture lines (brushstrokes) in a pattern based on level
            const lineCount = 5 + (stackLevel % 5);
            for (let i = 0; i < lineCount; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * brickCanvas.width, 0);
                ctx.lineTo(Math.random() * brickCanvas.width, brickCanvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, Math.random() * brickCanvas.height);
                ctx.lineTo(brickCanvas.width, Math.random() * brickCanvas.height);
                ctx.stroke();
            }
            
            // Add a subtle edge/border
            ctx.strokeStyle = '#8c001d';
            ctx.lineWidth = 6;
            ctx.strokeRect(3, 3, brickCanvas.width-6, brickCanvas.height-6);
            
            // Create a texture from the canvas
            const brickTexture = new THREE.CanvasTexture(brickCanvas);
            
            // Create material with the texture
            const brickMaterial = new THREE.MeshStandardMaterial({
                color: 0xbc002d, // Traditional red
                map: brickTexture,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Create the brick mesh
            const brick = new THREE.Mesh(brickGeometry, brickMaterial);
            brick.position.set(worldX, worldY, worldZ);
            brick.castShadow = true;
            brick.receiveShadow = true;
            
            // Store reference and add to scene
            brickStack.push(brick);
            scene.add(brick);
        }
        
        // Update camera position based on player position and direction
        function updateCameraPosition() {
            // Position the camera higher above and behind the player for better visibility
            const [dx, dz] = directions[direction];
            
            // Calculate an offset position behind the player
            const offsetDistance = 20; // Distance behind player
            const heightOffset = 20; // Height above player
            
            // Get current look direction based on rotation interpolation
            let rotationAngle = currentRotation;
            
            if (isRotating) {
                // Interpolate between current and target rotation
                const startAngle = currentRotation;
                const angleDiff = targetRotation - startAngle;
                
                // Handle wraparound for angle differences (going from 270° to 0° should rotate 90° not -270°)
                let shortestAngleDiff = ((angleDiff % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                if (shortestAngleDiff > Math.PI) {
                    shortestAngleDiff -= Math.PI * 2;
                }
                
                rotationAngle = startAngle + shortestAngleDiff * rotationProgress;
            }
            
            // Calculate camera position based on the interpolated angle
            const offsetX = Math.sin(rotationAngle) * offsetDistance;
            const offsetZ = Math.cos(rotationAngle) * offsetDistance;
            
            // Set the camera position
            camera.position.set(
                player.position.x - offsetX,
                player.position.y + heightOffset,
                player.position.z - offsetZ
            );
            
            // Make camera look at a point in front of the player
            const lookAtPoint = new THREE.Vector3(
                player.position.x + Math.sin(rotationAngle) * 30, // Look ahead of the player
                player.position.y,
                player.position.z + Math.cos(rotationAngle) * 30
            );
            camera.lookAt(lookAtPoint);
        }
        
        // Update camera rotation - now handles smooth transitions
        function updateCameraRotation() {
            updateCameraPosition(); // Just update the position which handles rotation too
        }
        
        // Handle direction changes with smooth rotation
        function changeDirection(newDirection) {
            // Don't start a new rotation if one is in progress
            if (isRotating) return;
            
            direction = newDirection;
            
            // Start rotation transition
            isRotating = true;
            rotationProgress = 0;
            
            // Store current rotation as starting point
            currentRotation = getCurrentAngleFromDirection();
            
            // Calculate target rotation based on new direction
            targetRotation = getAngleFromDirection(direction);
        }
        
        // Get the current camera angle (based on direction and any in-progress rotation)
        function getCurrentAngleFromDirection() {
            if (direction === 0) return Math.PI; // North
            if (direction === 1) return Math.PI / 2; // East
            if (direction === 2) return 0; // South
            if (direction === 3) return -Math.PI / 2; // West
            return 0;
        }
        
        // Get angle for a specific direction
        function getAngleFromDirection(dir) {
            if (dir === 0) return Math.PI; // North
            if (dir === 1) return Math.PI / 2; // East
            if (dir === 2) return 0; // South
            if (dir === 3) return -Math.PI / 2; // West
            return 0;
        }
        
        // Controls
        document.getElementById('turn-left').addEventListener('click', () => {
            changeDirection((direction + 3) % 4); // Turn left
        });
        
        document.getElementById('turn-right').addEventListener('click', () => {
            changeDirection((direction + 1) % 4); // Turn right
        });
        
        document.getElementById('pause').addEventListener('click', () => {
            isMoving = !isMoving;
            document.getElementById('pause').textContent = isMoving ? 'Pause' : 'Resume';
        });
        
        // Keyboard controls
        document.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowLeft') {
                changeDirection((direction + 3) % 4); // Turn left
            } else if (event.key === 'ArrowRight') {
                changeDirection((direction + 1) % 4); // Turn right
            } else if (event.key === ' ') {
                isMoving = !isMoving;
                document.getElementById('pause').textContent = isMoving ? 'Pause' : 'Resume';
            } else if (event.key === 'ArrowUp') {
                // Move forward manually
                movePlayer();
            } else if (event.key === 'ArrowDown') {
                // Turn 180 degrees instead of moving backward
                changeDirection((direction + 2) % 4);
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Add some clouds
        function createCloud(x, y, z) {
            const cloud = new THREE.Group();
            const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            
            // Create multiple spheres to form a cloud shape
            const sizes = [3, 2.5, 2, 3.5, 2.8];
            const positions = [
                [0, 0, 0],
                [2, 0.5, 1],
                [-1.5, 0, -1],
                [1, -0.5, -2],
                [-2, -0.3, 1.5]
            ];
            
            for (let i = 0; i < sizes.length; i++) {
                const cloudPartGeometry = new THREE.SphereGeometry(sizes[i], 16, 16);
                const cloudPart = new THREE.Mesh(cloudPartGeometry, cloudMaterial);
                cloudPart.position.set(positions[i][0], positions[i][1], positions[i][2]);
                cloud.add(cloudPart);
            }
            
            cloud.position.set(x, y, z);
            return cloud;
        }
        
        // Add some clouds to the scene
        const clouds = [];
        for (let i = 0; i < 10; i++) {
            const x = (Math.random() - 0.5) * 200;
            const y = 50 + Math.random() * 30;
            const z = (Math.random() - 0.5) * 200;
            const cloud = createCloud(x, y, z);
            clouds.push(cloud);
            scene.add(cloud);
        }
        
        // Animate clouds slowly
        function animateClouds() {
            clouds.forEach(cloud => {
                cloud.position.x += 0.05;
                if (cloud.position.x > 150) {
                    cloud.position.x = -150;
                }
            });
        }
        
        // Enhanced animation loop with cloud movement and post-processing
        function enhancedAnimate() {
            requestAnimationFrame(enhancedAnimate);
            
            deltaTime = clock.getDelta();
            
            // Handle movement transitions (jump animation)
            if (isTransitioning) {
                transitionProgress += deltaTime / transitionDuration;
                
                if (transitionProgress >= 1) {
                    // Transition complete
                    transitionProgress = 1;
                    isTransitioning = false;
                    moveCooldown = moveInterval / 1000 - transitionDuration; // Subtract transition time from cooldown
                }
                
                // Interpolate position with jump arc
                player.position.x = startPosition.x + (targetPosition.x - startPosition.x) * transitionProgress;
                player.position.z = startPosition.z + (targetPosition.z - startPosition.z) * transitionProgress;
                
                // Add jump height - parabola that peaks in the middle of the jump
                const jumpHeight = Math.sin(Math.PI * transitionProgress) * 2;
                player.position.y = startPosition.y + jumpHeight;
                
                // Make player rotate during jump
                player.rotation.x = Math.sin(Math.PI * transitionProgress) * Math.PI;
                
                // Update camera to follow player
                updateCameraPosition();
            } else {
                // Fix: Use proper height calculation instead of fixed value
                updatePlayerRestingHeight();
                player.rotation.x = 0;
            }
            
            // Handle camera rotation
            if (isRotating) {
                rotationProgress += deltaTime / rotationDuration;
                
                if (rotationProgress >= 1) {
                    // Rotation complete
                    rotationProgress = 1;
                    isRotating = false;
                    currentRotation = targetRotation;
                }
                
                // Smooth camera rotation
                updateCameraRotation();
            }
            
            if (moveCooldown > 0) {
                moveCooldown -= deltaTime;
            } else if (isMoving && !isTransitioning) {
                // Time to move again
                movePlayer();
            }
            
            // Rotate sun
            sun.position.x = 120 * Math.cos(clock.elapsedTime * 0.03);
            sun.position.z = 120 * Math.sin(clock.elapsedTime * 0.03);
            
            // Move moon in opposite direction
            moon.position.x = -120 * Math.cos(clock.elapsedTime * 0.03);
            moon.position.z = -120 * Math.sin(clock.elapsedTime * 0.03);
            
            // Update sunlight direction
            sunLight.position.copy(sun.position);
            
            // Animate clouds
            animateClouds();
            
            // Use composer for rendering with post-processing if available
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }
        
        // Start the animation
        enhancedAnimate();

        // Function to increment score and update display
        function incrementScore() {
            score += 1;
            document.getElementById('score-display').textContent = score;
            
            // Add a visual effect to the score display when it changes
            const scoreElement = document.querySelector('.score-container');
            scoreElement.style.transform = 'scale(1.1)';
            setTimeout(() => {
                scoreElement.style.transform = 'scale(1)';
            }, 200);
        }
    </script>
</body>
</html> 